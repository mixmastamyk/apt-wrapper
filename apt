#!/usr/bin/env python
''' A simpler interface to Debian APT commands. (C) 2012 Mike Miller
    License: GPLv3+
'''
import sys, os
from subprocess import call

__version__ = '0.93'
debug = False
use_sudo = ('apt-get', 'apt-get remove', 'aptitude', 'apt-key', 'dpkg -i')
# map commands to their appropriate binaries:
cmd_map = {
    # apt-get
    'autoclean': 'apt-get',
    'autoremove': 'apt-get',
    'build-dep': 'apt-get',
    'changelog': 'apt-get',
    'check': 'apt-get',
    'clean': 'apt-get',
    'dist-upgrade': 'apt-get',
    'download': 'apt-get',
    'dselect-upgrade': 'apt-get',
    'install': 'apt-get',
    'markauto': 'apt-get',
    'purge': 'apt-get',
    'remove': 'apt-get',
    'rm': 'apt-get remove',         # alias
    'source': 'apt-get',
    'unmarkauto': 'apt-get',
    'update': 'apt-get',
    'upgrade': 'apt-get',

    # cache
    'depends': 'apt-cache',
    'dotty': 'apt-cache',
    'dump': 'apt-cache',
    'dumpavail': 'apt-cache',
    'gencaches': 'apt-cache',
    'pkgnames': 'apt-cache',
    'policy': 'apt-cache',
    'rdepends': 'apt-cache',
    'search': 'apt-cache',
    'show': 'apt-cache',
    'showauto': 'apt-cache',
    'showpkg': 'apt-cache',
    'showsrc': 'apt-cache',
    'stats': 'apt-cache',
    'unmet': 'apt-cache',
    'xvcg': 'apt-cache',

    # config
    'shell': 'apt-config',
    'dumpcon': 'apt-config',

    # aptitude
    'hold': 'aptitude',
    'unhold': 'aptitude',
    'download': 'aptitude',
    'reinstall': 'aptitude',
    'changelog': 'aptitude',
    'why': 'aptitude',
    'why-not': 'aptitude',

    # more
    'fingerprint': 'apt-key',
    'list': 'dpkg-query -l',
    'query': 'dpkg-query -l',       # alias
    'listfiles': 'dpkg-query -L',
    'searchfiles': 'dpkg-query -S',
    'instdeb': 'dpkg -i',
}
commands = sorted(set(cmd_map.keys()))  # make a list for the user

def is_uniq(fragment):
    ''' Check whether a given command fragment uniquely identifies a command.
        Returns:  boolean, first command or None, all matches.
    '''
    results = [ c  for c in commands  if c.startswith(fragment) ]
    uniq = (len(results) == 1)
    return uniq, (results or [None])[0], results


# check & prepare args
args = sys.argv[1:]
if not args or ('-h' in args) or ('--help' in args):
    sys.exit('Error: no command given.  Must be one of: \n\n(%s).\n' %
             ', '.join(commands))
else:
    command = args[0]

# enable debug text
if '-d' in args:
    args.remove('-d')
    debug = True

# find binary
if command in cmd_map:
    binary = cmd_map[command]
else:
    uniq, command, matches = is_uniq(command)
    if debug:
        print 'Unique:', args[0], command
    if not uniq:
        sys.exit('Error: %s command, %s --> %s' % (
                 ('ambiguous' if matches else 'unknown'),
                 args[0], matches))
    binary = cmd_map[command]

# check for root permissions, don't elevate for cache operations
if binary in use_sudo and os.geteuid() != 0:
    prefix = 'sudo '
else:
    prefix = ''

# check if binary uses a flag instead of command
if ' ' in binary:
    binary, command = binary.split(' ', 1)


# build command line
cmdline = prefix + ' '.join([binary, command] + args[1:])
if debug:
    print 'Running:', cmdline

# http://youtu.be/0hiUuL5uTKc?t=8s
sys.exit(call(cmdline, shell=True))
